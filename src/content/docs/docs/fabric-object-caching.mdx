---
date: '2016-11-26'
description: 'Caching of object, properties and beahvior'
title: Caching of object, properties and beahvior
---
import { Example1, Example2, Example3, Example4 } from './fabric-object-caching/fabric-object-caching.jsx';

## Caching in Fabric.js

When fabric object caching is active, the objects you paint on canvas are actually pre painted on another smaller canvas,
 outside of the DOM, as big as the object pixel dimension itself.
During the `render` method this pre painted canvas gets copied on the main canvas with a `drawImage` operation.

That means that during `drag` `rotate` `skew` `scale` operations the object is not redrawn on canvas, but just its copied cached image gets drawn over the canvas.

In general every top level object on the fabric.canvas ends up on its own image counterpart stored on a HTMLCanvas
 of which a reference is saved in the property `_cacheCanvas`. Every render cycle the code checks if this object is dirty
 and in case it refreshes the copy and then uses it for painting again.

The caching strategy is very simple in Fabric.js and there are few properties on the objects or in the top level configuration to slightly tweak it.
In practice then this process has a lot of costrains and perfomance pitfalls. Please be sure to read this entire page to
 understand the basics.

## Tweaks and configuration

### Object configuration

Fabric.js objects have some top level properties to handle caching.

```ts
myObject.objectCaching = true;
```
objectCaching property is the main switch of caching per object.
When is false caching is skipped, unless is required because of some other constrain ( more on that later )

```ts
myObject.noScaleCache = true;
```
noScaleCache is a boolean that will stop cache invalidation during a scaling operation with the mouse.
At the end of the scaling operation the object will be redrawn and a new cache will be created for that scale value.

Also spot differences in scaling between `noScaleCache` true or false.  
In canvases below left canvas is `true`, that means that during the scaling transformation the object is not regenerated.
The right canvas has scaling that invalidates the cache every scale change.
You can also open your developer tools and record scaling performances in both cases and compare.
Take care that the below yellow care is a large complex object made of 417 innner objects and gradients.
if you scale an object more than 3 times the original size you will notice blurring that then gets fixed with a new cached
 copy as soon as you perform a mouse up. Try it by yourself:

<div style={{ display: 'flex', flexDirection: 'row', justifyContent: 'space-between' }}>
<Example3 client:idle hideCode />
<Example4 client:idle hideCode />
</div>

```ts
myObject.dirty = true;
```
This boolean flags the cache status as old/invalid/dirty and will cause a re-render at the next render cycle.
As of today there isn't a method to force cache refresh imperatively.

Fabric.js takes care to set the dirty flag during the operations that will likely cause a cache invalidation,
 like text typing for example.

### Classes configuration

On top of those per instance properties there are some that are at class level.
Each class has a static array of `cacheProperties` as this one below:

```ts
static cacheProperties = [
  'fill',
  'stroke',
  'strokeWidth',
  'strokeDashArray',
  'width',
  'height',
  'paintFirst',
  'strokeUniform',
  'strokeLineCap',
  'strokeDashOffset',
  'strokeLineJoin',
  'strokeMiterLimit',
  'backgroundColor',
  'clipPath',
];
```

Being static you will find this array on the class definition like:

```ts
import { Path } from 'fabric';

console.log(Path.cacheProperties);

// outputs
['fill', 'stroke', 'strokeWidth', ...]
```
This array is used from the `set` method to check on cache invalidation.
The moment you call:
```ts
myObject.set({ fill: 'red', name: 'John' });
```
Both keys fill and name get checked against the array and if one is found the object status is set to dirty.
It is suggested to always use the set method, with the object signature or the simpler one when you want to
 change properties to your objects to avoid stale caches.

If you are creating a custom class and you have some property that influences rendering you should add to your
 new class `cacheProperties` all the properties of the base class and add your own.

When a cache property is set in an object that is inside a group, all the parents of the object get invalidated as well.


### Fabric.js configuration

Caching has a list of compromises in order to be somehow convenient most of the time.
A cached canvas can't be too big or it will be too slow to be refreshed for example.
It can't be too small or it will not trigger certain GPU optmization paths in browsers
 ( this information may be obsolete with browser changes )

In the Fabric.js configuration object there are 3 values that relate to caching:

```ts
  /**
   * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.
   * @since 1.7.14
   * @type Number
   * @default
   */
  perfLimitSizeTotal = 2097152;

  /**
   * Pixel limit for cache canvases width or height. IE11 was the historical reason why this number is below 5000
   * @since 1.7.14
   * @type Number
   * @default
   */
  maxCacheSideLimit = 4096;

  /**
   * Lowest pixel limit for cache canvases, set at 256PX
   * @since 1.7.14
   * @type Number
   * @default
   */
  minCacheSideLimit = 256;
```

minCacheSideLimit will determine the mini size of a side of the cache. At any object size the cache canvas will be at least 256 by 256 pixels.
If you are caching a Rect that is 1 by 1, you will have a 256 by 156 canvas with a single pixel filled.

maxCacheSizeLimit and perfLimitSizeTotal are determining the maximum side and the maximum surface of the cache canvas.
So with a value of 4k pixels and a perfLimitSizeTotal of around 2 milion pixels, if your object is 5000 by 10000 it will cached to a size of
 4096 by (2097152 / 4096). The biggest side will be reduce to 4096 and the other one will be fit in what 2Milion pixels allow.

You can change those value to experiment with what quality and speed fit best for your application by doing the follwing:

```ts
import { config } from 'fabric';
config.perfLimitSizeTotal = 4096 * 1024;
config.maxCacheSideLimit = 8192;
```
Please continue reading for considerations of various kind, mobile performance, output quality when exporting and so on.

### Caching and render loop

This little paragraph will try to illustrate the logic of handling cache in Fabric.js.

### Performance pitfalls and issues

Performance gains are not always there and there are also issues.

It depends on what your project looks like. Are you drawing just a bunch of circles, rects and simple polygons?
 Maybe caching is not beneficial for you at all.

Are you importing and displaying large and complex svgs? well you will move from possibly shuttering to smooth. Is there any glich I should be aware of? Well you may not like the `noScaleCache` feature and that is why there is a flag to disable it.

### Sharp output and printing

Png or Jpeg exports with caching active is in general a bad idea.
Let's see why.

### Caching in action

Example of a cache canvas that is bigger than the drawn object (256x256 is the minimum by default):

<div style={{ width: '256px', height: '256px', border: '1px solid black'}}>
  <img src="/article_assets/carMinCache.png" style={{ width: '256px' }} />
</div>

Example of the biggest size cache canvas at default values ( 2 Mega pixels ). Scroll inside the white area to see image at 100% zoom:

<div style={{ width: '100%', height: '256px', overflow: 'scroll', border: '1px solid black'}}>
  <img src="/article_assets/carMaxCache.png" style={{ maxWidth: 'unset', width: '1773px' }} />
</div>

The default cache setting is not small, is enough for crisp images on a standard screen.

Below you can see 2 fabric canvases. The left one is the default cached, while the right one is drawn with cache disabled.  
The canvases are loaded with heavy pathgroups, the snowman, the heaviest I could find is in 3 copies and makes the render speed cripple down.
Try to drag around one of the shapes on the left or right canvas and notice the speed difference.
On a modern machine without caching is still usable, at the time of writing this article for the first time ( around 2017 ) the difference was night and day.

<Example1 client:idle hideCode canvasStyle={{ display: 'inline-block'}} />
<Example2 client:idle hideCode canvasStyle={{ display: 'inline-block'}} />

As a reference, on my machine, an m1 pro from 2021 the cached canvas takes 0.8ms to render, while the non cached one takes 25ms.
