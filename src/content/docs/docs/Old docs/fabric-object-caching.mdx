---
date: '2016-11-26'
description: 'Caching of object, properties and beahvior'
title: Caching of object, properties and beahvior
---
import { Example1, Example2, Example3 } from './fabric-object-caching/fabric-object-caching.jsx';

## Caching in Fabric.js

When fabric object caching is active, the objects you paint on canvas are actually pre painted on another smaller canvas,
 outside of the DOM, as big as the object pixel dimension itself.
During the `render` method this pre painted canvas gets copied on the main canvas with a `drawImage` operation.

That means that during `drag` `rotate` `skew` `scale` operations the object is not redrawn on canvas, but just its copied cached image gets drawn over the canvas.

In general every top level object on the fabric.canvas ends up on its own image counterpart stored on a HTMLCanvas
 of which a reference is saved in the property `_cacheCanvas`. Every render cycle the code checks if this object is dirty
 and in case it refreshes the copy and then uses it for painting again.

The caching strategy is very simple in Fabric.js and there are few properties on the objects or in the top level configuration to slightly tweak it.
In practice then this process has a lot of costrains and perfomance pitfalls. Please be sure to read this entire page to
 understand the basics.

## Tweaks and configuration

### Object configuration

Fabric.js objects have some top level properties to handle caching.

```ts
myObject.objectCaching = true;
```
objectCaching property is the main switch of caching per object.
When is false caching is skipped, unless is required because of some other constrain ( more on that later )

```ts
myObject.noScaleCache = true;
```
noScaleCache is a boolean that will stop cache invalidation during a scaling operation with the mouse.
At the end of the scaling operation the object will be redrawn and a new cache will be created for that scale value.

```ts
myObject.dirty = true;
```
This boolean flags the cache status as old/invalid/dirty and will cause a re-render at the next render cycle.
As of today there isn't a method to force cache refresh imperatively.

### Classes configuration

On top of those per instance properties there are some that are at class level.
Each class has a static array of `cacheProperties` as this one below:

```ts
static cacheProperties = [
  'fill',
  'stroke',
  'strokeWidth',
  'strokeDashArray',
  'width',
  'height',
  'paintFirst',
  'strokeUniform',
  'strokeLineCap',
  'strokeDashOffset',
  'strokeLineJoin',
  'strokeMiterLimit',
  'backgroundColor',
  'clipPath',
];
```

Being static you will find this array on the class definition like:

```ts
import { Path } from 'fabric';

console.log(Path.cacheProperties);

// outputs
['fill', 'stroke', 'strokeWidth', ...]
```
This array is used from the `set` method to check on cache invalidation.
The moment you call:
```ts
myObject.set({ fill: 'red', name: 'John' });
```
Both keys fill and name get checked against the array and if one is found the object status is set to dirty.
It is suggested to always use the set method, with the object signature or the simpler one when you want to
 change properties to your objects to avoid stale caches.

### Fabric.js configuration

Caching has a list of compromises in order to be somehow convenient most of the time.
A cached canvas can't be too big or it will be too slow to be refreshed for example.
It can't be too small or it will not trigger certain GPU optmization paths in browsers
 ( this information may be obsolete with browser changes )

In the Fabric.js configuration object there are 3 values that relate to caching:

```ts
  /**
   * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.
   * @since 1.7.14
   * @type Number
   * @default
   */
  perfLimitSizeTotal = 2097152;

  /**
   * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000
   * @since 1.7.14
   * @type Number
   * @default
   */
  maxCacheSideLimit = 4096;

  /**
   * Lowest pixel limit for cache canvases, set at 256PX
   * @since 1.7.14
   * @type Number
   * @default
   */
  minCacheSideLimit = 256;
```

minCacheSideLimit will determine the mini size of a side of the cache. At any object size the cache canvas will be at least 256 by 256 pixels.
If you are caching a Rect that is 1 by 1, you will have a 256 by 156 canvas with a single pixel filled.

maxCacheSizeLimit and perfLimitSizeTotal are determining the maximum side and the maximum surface of the cache canvas.
So with a value of 4k pixels and a perfLimitSizeTotal of around 2 milion pixels, if your object is 5000 by 10000 it will cached to a size of
 4096 by (2097152 / 4096). The biggest side will be reduce to 4096 and the other one will be fit in what 2Milion pixels allow.

You can change those value to experiment with what quality and speed fit best for your application by doing the follwing:

```ts
import { config } from 'fabric';
config.perfLimitSizeTotal = 4096 * 1024;
config.maxCacheSideLimit = 8192;
```
Please continue reading for considerations of various kind, mobile performance, output quality when exporting and so on.

### Caching and render logic

### Sharp output and printing

### Performance pitfalls


Example of a cache canvas that is bigger than the drawn object (256x256 is the minimum by default):

![](/article_assets/carMinCache.png)

Example of the biggest size cache canvas at default values ( 2 Mega pixels ). Scroll to see something:

### How much performance gain I get, are there any problems?

It depends on what your project looks like. Are you drawing just a bunch of circles, rects and simple polygons? Maybe you will not gain that much performance.  
Are you importing and displaying large and complex svgs? well you will move from possibly shuttering to smooth. Is there any glich I should be aware of? Well you may not like the `noScaleCache` feature and that is why there is a flag to disable it.

### What about compatibility problem with my current project? Should I update? Can I disable caching?

I would say yes, switch to 1.7.0, check if everything is fine. If not report any visual problem to issue tracker, you can still completly disable the feature everywhere doing:

fabric.Object.prototype.objectCaching = false;

to override the standard value and cache will be disabled for your project.

### Live samples

Below you can see 2 fabric canvases. The left one is the default cached one, while the right one is drawn with cache disabled as it was on previous versions.  
The canvases are loaded with heavy pathgroups, the snowwhite, the heaviest I could find is in 3 copies and makes the render speed cripple down. Try to drag around one of the shapes on the left or right canvas and notice the speed difference.

<Example1 client:idle hideCode canvasStyle={{ display: 'inline-block'}} />
<Example2 client:idle hideCode canvasStyle={{ display: 'inline-block'}} />

Also spot differences in scaling between `noScaleCache` with values true or false.  
In canvases below Left canvas is `false`, that means that during the scaling tasnformation the obect is not regenerated. if you scale an object more than 3 times the original size you will notice blurring that then gets fixed with a new cached copy as soon as you perform a mouse up. Try it by yourself:

<Example3 client:idle hideCode />


### When does the cache gets updated with a new version?

Fabric has a hardcoded trigger to update the cache during the built in functions where the developer has no easy way to insert code.  
Those situations are: `scaling`, `typing text`, `canvas global zoom`.  
In all other cases, it's the developer that's changing some property of an object, and should therefore make sure to force a cache update by setting the object's `dirty` property to true when necessary. So calling `object.set('fill', 'red')` require no other actions. If for some reason you are not using the set method (for example in situation of text objects in which setting some properties triggers expensive functions) you will use the flag.  
There is also a way to ask fabric to check at render time a change for properties. This is not expensive most of the time but I decided to leave it off because in crowded situations ( like spray brush or 1000+ svg paths ) it was expensive.  
Groups and PathGroups are taken care of in this way:  
When an object gets set a property, the property is checked, if it is in the `cacheProperties` array, the object and the group is set as dirty. If the property is in the `stateProperties` array, only the group is set as dirty.

### How does fabric check for changes in custom subclasses with custom properties?

Custom subclassing is one of the fabric strongest features in my opinion and object caching has been built with that in mind.. So there is an array defined called `cacheProperties` that contains a list of properties that get checked at every render when the property `statefullCache` is set true. (defaults to false).  
The array looks like this:
```js
  cacheProperties: (
    'fill stroke strokeWidth strokeDashArray width height' +
    ' strokeLineCap strokeLineJoin strokeMiterLimit fillRule backgroundColor'
  ).split(' '),
```
and gets more properties in different sublcasses, for example rect adds `rx` and `ry` and so on. The properties are checked recursively, that means that at every change detected a copy of the property is saved, and at next render is compared deeply. Normally properties that need deep checks are gradients, patterns, path array, strokeDash. If your application make no use of some properties at all you can remove them from the cacheProperties array and make the check faster, or you can add your custom properties that influence rendering to have them checked.

### Gotchas

Image is cut of of object bounding box: **YES**. There is an invisible canvas that keep a copy of the object. This canvas is sized with objects width/height. If width and height are not correct for the object we are trying to display, the image will be cut off. There is no other solution than disable the caching for the object or fix the problem.  
Currently affected uses case:

- (mainly solved since 1.7.7) sometimes things can look blurry
- (mainly solved since 1.7.8) paths with wrongly parsed command sequence (very few)
- (mainly solved since 1.7.3) Text using custom fonts with very big ascender/descender and of wich canvas is not able to measure extension.
- Groups not initialized correctly ( created empty and not updated after using the .add method, please use addWithUpdate)
- Scaling events that reset scale and modify width/height, disable `noScaleCache`, set it to false